<script>
  document.addEventListener('DOMContentLoaded', () => {
    /*Mobile settings*/
    const MOBILE_BREAKPOINT = 1023;
    const isMobile = () => window.innerWidth <= MOBILE_BREAKPOINT;

    /*Implementation modal*/

    const triggers =
      document.querySelectorAll('.testartem .modal-trigger') ||
      document.querySelectorAll('.modal-trigger');

    const closeAllModals = (exceptModal = null) => {
      document.querySelectorAll('.testartem .modal.is-open, .modal.is-open').forEach((modal) => {
        if (exceptModal && modal === exceptModal) return;
        modal.classList.remove('is-open');
      });

      if (!document.querySelector('.testartem .modal.is-open, .modal.is-open')) {
        document.body.classList.remove('modal-open');
      }
    };

    const openModal = (modal) => {
      modal.classList.add('is-open');
      document.body.classList.add('modal-open');
    };

    const closeModal = (modal) => {
      modal.classList.remove('is-open');

      if (!document.querySelector('.testartem .modal.is-open, .modal.is-open')) {
        document.body.classList.remove('modal-open');
      }
    };

    triggers.forEach((trigger) => {
      const modalId = trigger.dataset.modal;
      const modal = document.getElementById(modalId);
      if (!modal) return;

      const closeBtn = modal.querySelector('.modal-close');

      trigger.addEventListener('click', (e) => {
        if (!isMobile()) return;
        e.preventDefault();
        e.stopPropagation();

        if (modal.classList.contains('is-open')) {
          closeModal(modal);
          return;
        }

        closeAllModals(modal);
        openModal(modal);
      });

      trigger.addEventListener('mouseenter', () => {
        if (isMobile()) return;
        openModal(modal);
      });

      trigger.addEventListener('mouseleave', () => {
        if (isMobile()) return;
        closeModal(modal);
      });

      modal.addEventListener('mouseenter', () => {
        if (isMobile()) return;
        openModal(modal);
      });

      modal.addEventListener('mouseleave', () => {
        if (isMobile()) return;
        closeModal(modal);
      });

      closeBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        closeModal(modal);
      });
    });

    document.addEventListener('click', (e) => {
      if (!isMobile()) return;

      const openModalEl = document.querySelector('.testartem .modal.is-open, .modal.is-open');
      if (!openModalEl) return;

      const content = openModalEl.querySelector('.modal-inner');
      if (!content) return;

      if (!content.contains(e.target) && !e.target.closest('.modal-trigger')) {
        closeAllModals();
      }
    });

    window.addEventListener('resize', closeAllModals);

    /*Implementation slider - Sticky scroll approach*/
    const section =
      document.querySelector('.testartem .implementation') ||
      document.querySelector('.implementation');
    if (!section) return;

    const inner = section.querySelector('.implementation__inner');
    if (!inner) return;

    const btnNext = section.querySelector('.implementation__nav-btn.next');
    const btnPrev = section.querySelector('.implementation__nav-btn.prev');
    const itemNumEl = section.querySelector('.implementation__item-num span');

    // -------------------------
    // CONFIG
    // -------------------------
    const MAX_ITEMS = 5;
    
    // –ú–Ω–æ–∂–Ω–∏–∫ –≤–∏—Å–æ—Ç–∏ –¥–ª—è scroll (480vh –¥–ª—è —Å–ª–∞–π–¥—ñ–≤ = 4.8)
    const SCROLL_HEIGHT_MULTIPLIER = 4.8;
    // –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Å–ª–∞–π–¥—É (50vh = 0.5)
    const EXTRA_SPACE_AFTER_LAST = 0.5;
    // –ó–∞–≥–∞–ª—å–Ω–∞ –≤–∏—Å–æ—Ç–∞ = 530vh (4.8 + 0.5 = 5.3)
    
    // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–µ–∞–ª—å–Ω—É –≤–∏—Å–æ—Ç—É –∫–æ–Ω—Ç–µ–Ω—Ç—É
    const getContentHeight = () => {
        const body = section.querySelector('.implementation__body');
        if (!body) return window.innerHeight;
        return body.offsetHeight || body.getBoundingClientRect().height;
    };
    
    // –í–∏—Å–æ—Ç–∞ —Å–µ–∫—Ü—ñ—ó –¥–ª—è scroll = viewport height * (–º–Ω–æ–∂–Ω–∏–∫ + –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä)
    // 480vh –¥–ª—è —Å–ª–∞–π–¥—ñ–≤ + 50vh –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ = 530vh –∑–∞–≥–∞–ª–æ–º
    const getScrollHeight = () => {
        const vh = window.innerHeight || document.documentElement.clientHeight;
        return vh * (SCROLL_HEIGHT_MULTIPLIER + EXTRA_SPACE_AFTER_LAST);
    };

    // -------------------------
    // HELPERS
    // -------------------------
    const clamp = (n, min, max) => Math.min(Math.max(n, min), max);

    const getActiveIndex = () => {
      const m = inner.className.match(/item-(\d+)-active/);
      const n = m ? parseInt(m[1], 10) : 1;
      return clamp(n, 1, MAX_ITEMS);
    };

    const setActiveIndex = (index) => {
      const next = clamp(index, 1, MAX_ITEMS);

      for (let i = 1; i <= MAX_ITEMS; i++) inner.classList.remove(`item-${i}-active`);
      inner.classList.add(`item-${next}-active`);

      if (itemNumEl) itemNumEl.textContent = String(next).padStart(2, '0');

      if (btnPrev) btnPrev.disabled = next === 1;
      if (btnNext) btnNext.disabled = next === MAX_ITEMS;
    };

    const step = (dir) => {
        const currentIndex = getActiveIndex();
        const newIndex = clamp(currentIndex + dir, 1, MAX_ITEMS);
        
        // –ù–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–º–∏–∫–∞—î–º–æ items
        if (isMobile()) {
            setActiveIndex(newIndex);
            return;
        }
        
        // –ù–∞ –¥–µ—Å–∫—Ç–æ–ø—ñ - —Å–∫—Ä–æ–ª–∏–º–æ –¥–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –º—ñ—Å—Ü—è
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const sectionTop = section.offsetTop;
        const scrollHeight = getScrollHeight();
        
        // Progress –¥–ª—è –Ω–æ–≤–æ–≥–æ item (0-1 –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ item)
        const itemProgress = (newIndex - 1) / (MAX_ITEMS - 1);
        const targetScroll = sectionTop + (scrollHeight - vh) * itemProgress;
        
        window.scrollTo({
            top: targetScroll,
            behavior: 'smooth'
        });
    };

    // –û–±—á–∏—Å–ª—é—î–º–æ progress —Å–∫—Ä–æ–ª—É –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Å–µ–∫—Ü—ñ—ó (0-1)
    const getScrollProgress = () => {
        if (isMobile()) return 0; // –ù–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ scroll progress
        
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const scrollHeight = getScrollHeight();
        
        // –ö–æ–ª–∏ —Å–µ–∫—Ü—ñ—è –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è (top = 0) -> progress = 0
        // –ö–æ–ª–∏ —Å–µ–∫—Ü—ñ—è –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è (top = scrollHeight - vh) -> progress = 1
        const sectionTop = section.offsetTop;
        const currentScroll = window.scrollY;
        const scrollStart = sectionTop;
        const scrollEnd = sectionTop + scrollHeight - vh;
        
        if (currentScroll < scrollStart) return 0;
        if (currentScroll > scrollEnd) return 1;
        
        return (currentScroll - scrollStart) / (scrollEnd - scrollStart);
    };

    // –û–Ω–æ–≤–ª—é—î–º–æ –∞–∫—Ç–∏–≤–Ω–∏–π item –Ω–∞ –æ—Å–Ω–æ–≤—ñ scroll progress
    const updateActiveItemFromScroll = () => {
        if (isMobile()) return; // –ù–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –Ω–µ –æ–Ω–æ–≤–ª—é—î–º–æ —á–µ—Ä–µ–∑ scroll
        
        const progress = getScrollProgress();
        
        // –û–±—á–∏—Å–ª—é—î–º–æ item index –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º —Ç–æ–≥–æ, —â–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Å–ª–∞–π–¥ –º–∞—î –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä
        // Progress 0.0 -> item 1, progress ~0.906 (480/530) -> item 5, progress 1.0 -> item 5
        // –ü–µ—Ä—à—ñ 4 —Å–ª–∞–π–¥–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª–µ–Ω—ñ –Ω–∞ 480vh, –æ—Å—Ç–∞–Ω–Ω—ñ–π —Å–ª–∞–π–¥ + 50vh = 530vh
        const slidesProgress = SCROLL_HEIGHT_MULTIPLIER / (SCROLL_HEIGHT_MULTIPLIER + EXTRA_SPACE_AFTER_LAST); // ~0.906
        
        let itemIndex;
        if (progress >= slidesProgress) {
            // –û—Å—Ç–∞–Ω–Ω—ñ–π —Å–ª–∞–π–¥ (5) –∞–∫—Ç–∏–≤–Ω–∏–π –≤—ñ–¥ progress ~0.906 –¥–æ 1.0
            itemIndex = MAX_ITEMS;
        } else {
            // –ü–µ—Ä—à—ñ 4 —Å–ª–∞–π–¥–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª–µ–Ω—ñ –Ω–∞ progress 0.0 - ~0.906
            const normalizedProgress = progress / slidesProgress; // –Ω–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
            itemIndex = Math.floor(normalizedProgress * (MAX_ITEMS - 1)) + 1;
        }
        
        const clampedIndex = clamp(itemIndex, 1, MAX_ITEMS);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –∑–º—ñ–Ω–∏–≤—Å—è
        if (clampedIndex !== getActiveIndex()) {
            setActiveIndex(clampedIndex);
        }
    };

    // -------------------------
    // BUTTONS
    // -------------------------
    btnNext?.addEventListener('click', (e) => { 
        e.preventDefault(); 
        step(+1); 
    });
    btnPrev?.addEventListener('click', (e) => { 
        e.preventDefault(); 
        step(-1); 
    });

    // -------------------------
    // MOBILE SWIPE (left/right)
    // -------------------------
    let touchStartX = 0;
    let touchStartY = 0;

    const SWIPE_MIN_DIST = 40;
    const SWIPE_MAX_ANGLE = 0.6;

    section.addEventListener(
      'touchstart',
      (e) => {
        if (!isMobile()) return;
        const t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
      },
      { passive: true },
    );

    section.addEventListener(
      'touchend',
      (e) => {
        if (!isMobile()) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;

        if (Math.abs(dx) < SWIPE_MIN_DIST) return;
        if (Math.abs(dy) > Math.abs(dx) * SWIPE_MAX_ANGLE) return;

        if (dx < 0) step(+1);
        else step(-1);
      },
      { passive: true },
    );

    // -------------------------
    // SCROLL LISTENER: –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ item
    // -------------------------
    let scrollRafId = null;
    const handleScroll = () => {
        if (scrollRafId) return;
        
        scrollRafId = requestAnimationFrame(() => {
            updateActiveItemFromScroll();
            scrollRafId = null;
        });
    };

    window.addEventListener('scroll', handleScroll, { passive: true });

    // -------------------------
    // INIT / RESIZE
    // -------------------------
    setActiveIndex(getActiveIndex());
    updateActiveItemFromScroll(); // –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω

    let resizeTimer = null;
    window.addEventListener('resize', () => {
        // Debounce resize –¥–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            updateActiveItemFromScroll();
            resizeTimer = null;
        }, 150);
    });

    /*Show more / less*/
    const list =
      document.querySelector('.testartem .about__list') || document.querySelector('.about__list');
    if (!list) return;

    // ‚úÖ –∞–∫—Ç—É–∞–ª—å–Ω—ñ items
    const getItems = () => [...list.querySelectorAll('.about__list-item')];

    // ‚úÖ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π DOM-–ø–æ—Ä—è–¥–æ–∫, —â–æ–± –º–æ–∂–Ω–∞ –±—É–ª–æ –≤—ñ–¥–∫–æ—Ç–∏—Ç–∏—Å—å
    const initialOrder = getItems();

    // ===== Mobile helpers =====
    function closeDesc(desc) {
      desc.classList.add('is-collapsed');
      desc.style.setProperty('max-height', '0px', 'important');
    }

    function openDesc(desc) {
      desc.classList.remove('is-collapsed');
      desc.style.setProperty('max-height', desc.scrollHeight + 'px', 'important');
    }

    function resetDesktop(desc) {
      desc.classList.remove('is-collapsed');
      desc.style.removeProperty('max-height');
    }

    // ===== Reset states =====
    function resetDesktopClasses() {
      list.classList.remove('is-expanded');
      getItems().forEach((li) => li.classList.remove('is-active', 'is-left', 'is-right'));
    }

    function applyMobileState() {
      resetDesktopClasses();

      getItems().forEach((li) => {
        const desc = li.querySelector('.about__list-item--description');
        const btn = li.querySelector('.about__list-item--btn');
        if (!desc || !btn) return;

        btn.style.setProperty('display', 'inline-block', 'important');

        const isOpen = btn.classList.contains('is-open');
        isOpen ? openDesc(desc) : closeDesc(desc);

        btn.textContent = isOpen ? 'Read less' : 'Read more';
      });
    }

    function applyDesktopState() {
      getItems().forEach((li) => {
        const desc = li.querySelector('.about__list-item--description');
        const btn = li.querySelector('.about__list-item--btn');

        if (desc) resetDesktop(desc);

        if (btn) {
          btn.style.setProperty('display', 'none', 'important');
          btn.classList.remove('is-open');
          btn.textContent = '';
        }
      });

      resetDesktopClasses();

      // ‚úÖ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥—ñ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø
      initialOrder.forEach((el) => list.appendChild(el));
    }

    // ===== FLIP =====
    function flipAnimate(container, mutate, duration = 520) {
      const els = Array.from(container.children);

      const first = new Map(els.map((el) => [el, el.getBoundingClientRect()]));

      mutate();

      container.getBoundingClientRect(); // force layout

      const last = new Map(els.map((el) => [el, el.getBoundingClientRect()]));

      els.forEach((el) => {
        const f = first.get(el);
        const l = last.get(el);
        if (!f || !l) return;

        const dx = f.left - l.left;
        const dy = f.top - l.top;

        if (dx || dy) {
          el.style.setProperty('transform', `translate(${dx}px, ${dy}px)`, 'important');
          el.style.setProperty('transition', 'transform 0s', 'important');
        }
      });

      requestAnimationFrame(() => {
        els.forEach((el) => {
          if (el.style.transform) {
            el.style.setProperty('transition', `transform ${duration}ms ease`, 'important');
            el.style.setProperty('transform', '', 'important');
          }
        });
      });

      setTimeout(() => {
        els.forEach((el) => {
          el.style.removeProperty('transition');
          el.style.removeProperty('transform');
        });
      }, duration + 60);

      return duration;
    }

    // ===== Desktop click =====
    list.addEventListener('click', (e) => {
      // ===== MOBILE =====
      if (isMobile()) {
        const btn = e.target.closest('.about__list-item--btn');
        if (!btn) return;

        const li = btn.closest('.about__list-item');
        if (!li) return;

        const desc = li.querySelector('.about__list-item--description');
        if (!desc) return;

        btn.classList.toggle('is-open');
        const nowOpen = btn.classList.contains('is-open');

        nowOpen ? openDesc(desc) : closeDesc(desc);
        btn.textContent = nowOpen ? 'Read less' : 'Read more';
        return;
      }

      // ===== DESKTOP =====
      const img = e.target.closest('.about__list-item--img');
      if (!img) return;

      const activeItem = img.closest('.about__list-item');
      if (!activeItem) return;

      const itemsBefore = getItems(); // DOM –ø–æ—Ä—è–¥–æ–∫ –î–û –∑–º—ñ–Ω
      const activeIndex = itemsBefore.indexOf(activeItem);
      const wasActive = activeItem.classList.contains('is-active');

      // toggle OFF: –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –ø–æ—Ä—è–¥–æ–∫ + –∑–Ω—ñ–º–∞—î–º–æ –∫–ª–∞—Å–∏ (–ø–ª–∞–≤–Ω–æ —á–µ—Ä–µ–∑ FLIP)
      if (wasActive) {
        flipAnimate(
          list,
          () => {
            resetDesktopClasses();
            initialOrder.forEach((el) => list.appendChild(el));
          },
          520,
        );
        return;
      }

      // toggle ON: –∞–∫—Ç–∏–≤–Ω–∏–π —Å—Ç–∞—î –ø–µ—Ä—à–∏–º, —ñ–Ω—à—ñ —Ä–æ–∑'—ó–∂–¥–∂–∞—é—Ç—å—Å—è
      flipAnimate(
        list,
        () => {
          // reset
          resetDesktopClasses();

          // 1) –∞–∫—Ç–∏–≤–Ω–∏–π –Ω–∞ –ø–µ—Ä—à–µ –º—ñ—Å—Ü–µ
          list.prepend(activeItem);

          // 2) –∞–∫—Ç–∏–≤–Ω–∏–π –∫–ª–∞—Å
          activeItem.classList.add('is-active');

          // 3) —Ö—Ç–æ –±—É–≤ –î–û –∞–∫—Ç–∏–≤–Ω–æ–≥–æ -> –≤–ª—ñ–≤–æ, —Ö—Ç–æ –ü–Ü–°–õ–Ø -> –≤–ø—Ä–∞–≤–æ
          itemsBefore.forEach((item, i) => {
            if (item === activeItem) return;
            if (i < activeIndex) item.classList.add('is-left');
            else item.classList.add('is-right');
          });

          // 4) –≤–º–∏–∫–∞—î–º–æ —Ä–æ–∑'—ó–∑–¥ (CSS —Ä–æ–±–∏—Ç—å translateX –¥–ª—è left/right)
          list.classList.add('is-expanded');
        },
        520,
      );
    });

    // ===== transitionend —Ç—ñ–ª—å–∫–∏ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–æ–≥–æ –æ–ø–∏—Å—É =====
    getItems().forEach((li) => {
      const desc = li.querySelector('.about__list-item--description');
      if (!desc) return;

      desc.addEventListener('transitionend', (ev) => {
        if (ev.propertyName !== 'max-height') return;
        if (!isMobile()) return;

        if (!desc.classList.contains('is-collapsed')) {
          desc.style.setProperty('max-height', 'none', 'important');
        }
      });
    });

    // ===== Init + resize =====
    let lastMode = isMobile() ? 'mobile' : 'desktop';

    function init() {
      const mode = isMobile() ? 'mobile' : 'desktop';
      mode === 'mobile' ? applyMobileState() : applyDesktopState();
      lastMode = mode;
    }

    init();

    window.addEventListener('resize', () => {
      const mode = isMobile() ? 'mobile' : 'desktop';
      if (mode === lastMode) return;
      init();
    });

    /*Tabs*/
    document.querySelectorAll('.testartem .tabs, .tabs').forEach((tabs) => {
      const section = tabs.closest('.how-it-works'); // üëà —Å–µ–∫—Ü—ñ—è –∑ —Ñ–æ–Ω–æ–º
      const buttons = [...tabs.querySelectorAll('[data-tab]')];
      const panels = [...tabs.querySelectorAll('[data-tab-target]')];

      if (!buttons.length || !panels.length) return;

      const interval = parseInt(tabs.dataset.interval, 10) || 4000;

      const order = buttons.map((btn) => btn.dataset.tab);

      let currentIndex = Math.max(
        0,
        buttons.findIndex((btn) => btn.classList.contains('is-active')),
      );
      if (currentIndex === -1) currentIndex = 0;

      let timer = null;

      const setBackgroundClass = (name) => {
        if (!section) return;

        // –ø—Ä–∏–±–∏—Ä–∞—î–º–æ –≤—Å—ñ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ how-it-works--*
        section.className = section.className
          .split(' ')
          .filter((cls) => !cls.startsWith('how-it-works--'))
          .join(' ');

        // –¥–æ–¥–∞—î–º–æ –Ω–æ–≤–∏–π
        section.classList.add(`how-it-works--${name}`);
      };

      const activateByName = (name) => {
        buttons.forEach((btn) => btn.classList.toggle('is-active', btn.dataset.tab === name));

        panels.forEach((panel) =>
          panel.classList.toggle('is-active', panel.dataset.tabTarget === name),
        );

        setBackgroundClass(name);
        currentIndex = order.indexOf(name);
      };

      const next = () => {
        const nextIndex = (currentIndex + 1) % order.length;
        activateByName(order[nextIndex]);
      };

      const start = () => {
        stop();
        timer = setInterval(next, interval);
      };

      const stop = () => {
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
      };

      // –∫–ª—ñ–∫–∏ –ø–æ —Ç–∞–±–∞—Ö
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          activateByName(btn.dataset.tab);
          start(); // –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ü–∏–∫–ª—É
        });
      });

      // init
      activateByName(order[currentIndex]);
      start();

      // –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è: –Ω–µ –∫—Ä—É—Ç–∏—Ç–∏ —É –Ω–µ–∞–∫—Ç–∏–≤–Ω—ñ–π –≤–∫–ª–∞–¥—Ü—ñ –±—Ä–∞—É–∑–µ—Ä–∞
      document.addEventListener('visibilitychange', () => {
        document.hidden ? stop() : start();
      });
    });

    /*Parallax for CTA*/
    const ctaSection = document.querySelector('.testartem .cta') || document.querySelector('.cta');
    if (!ctaSection) return;

    const ctaBg = ctaSection.querySelector('.cta__bg');
    if (!ctaBg) return;

    const DESKTOP_BREAKPOINT = 1024;

    let MAX_OFFSET_PX = 120; // desktop default
    let isTicking = false;
    let isInView = true;

    const applySettings = () => {
      if (window.innerWidth >= DESKTOP_BREAKPOINT) {
        // üñ• DESKTOP
        MAX_OFFSET_PX = 280; // –º–æ–∂–µ—à –∑–±—ñ–ª—å—à–∏—Ç–∏ –¥–æ 160
      } else {
        // üì± MOBILE
        MAX_OFFSET_PX = 150; // –∞–±–æ 0, —è–∫—â–æ –Ω–µ —Ö–æ—á–µ—à –ø–∞—Ä–∞–ª–∞–∫—Å –Ω–∞ –º–æ–±—ñ–ª—Ü—ñ
      }
    };

    applySettings();

    const updateParallax = () => {
      const rect = ctaSection.getBoundingClientRect();
      const vh = window.innerHeight;

      isInView = rect.bottom > 0 && rect.top < vh;
      if (!isInView) {
        isTicking = false;
        return;
      }

      const progress = (vh - rect.top) / (vh + rect.height);
      const clamped = Math.min(Math.max(progress, 0), 1);

      const translateY = (clamped - 0.5) * MAX_OFFSET_PX * 2;

      ctaBg.style.setProperty('transform', `translate3d(0, ${translateY}px, 0)`, 'important');

      isTicking = false;
    };

    const requestUpdate = () => {
      if (isTicking) return;
      isTicking = true;
      requestAnimationFrame(updateParallax);
    };

    window.addEventListener('scroll', requestUpdate, { passive: true });
    window.addEventListener('resize', () => {
      applySettings();
      requestUpdate();
    });

    // —Å—Ç–∞—Ä—Ç
    requestUpdate();

    /*Reviews read more*/
    const blocks = document.querySelectorAll(
      '.testartem .reviews__list-text[data-words], .reviews__list-text[data-words]',
    );

    blocks.forEach((block) => {
      const wordsLimit = parseInt(block.dataset.words, 10);
      if (!wordsLimit) return;

      const p = block.querySelector('p');
      if (!p) return;

      const fullText = (p.textContent || '').trim();
      const words = fullText.split(/\s+/);
      if (words.length <= wordsLimit) return;

      const shortText = words.slice(0, wordsLimit).join(' ') + '‚Ä¶';

      // wrap text only (button will be outside)
      const inner = document.createElement('div');
      inner.className = 'reviews__list-text-inner';
      block.insertBefore(inner, p);
      inner.appendChild(p);

      // button
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'reviews__read-more';
      block.appendChild(btn);

      let isOpen = false;

      const setBtn = () => (btn.textContent = isOpen ? 'Read less' : 'Read more');

      const setMaxHeightToContent = () => {
        // —Å—Ç–∞–≤–∏–º–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É –≤–∏—Å–æ—Ç—É, —â–æ–± –±—É–≤ slide
        inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');
      };

      const setClosedHeight = () => {
        // –≤–∞–∂–ª–∏–≤–æ: –∑–∞–º—ñ—Ä –≤–∏—Å–æ—Ç–∏ –∑ –∫–æ—Ä–æ—Ç–∫–∏–º —Ç–µ–∫—Å—Ç–æ–º
        inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');
      };

      const open = () => {
        // 1) —Å—Ç–∞–≤–∏–º–æ –ø–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç
        p.textContent = fullText;

        // 2) —Å–∫–∏–¥–∞—î–º–æ max-height –Ω–∞ 0 —ñ –æ–¥—Ä–∞–∑—É —Å—Ç–∞–≤–∏–º–æ –ø–æ—Ç—Ä—ñ–±–Ω—É (–¥–ª—è –Ω–∞–¥—ñ–π–Ω–æ–≥–æ transition)
        inner.style.setProperty('max-height', '0px', 'important');
        inner.getBoundingClientRect(); // force reflow
        setMaxHeightToContent();
      };

      const close = () => {
        // 1) —Ñ—ñ–∫—Å—É—î–º–æ –ø–æ—Ç–æ—á–Ω—É –≤–∏—Å–æ—Ç—É (–∑ fullText)
        inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');
        inner.getBoundingClientRect(); // force reflow

        // 2) —Å—Ç–∞–≤–∏–º–æ –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç
        p.textContent = shortText;

        // 3) —Å—Ç–∞–≤–∏–º–æ max-height –ø—ñ–¥ –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç
        setClosedHeight();
      };

      // –ø—ñ—Å–ª—è –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –º–æ–∂–Ω–∞ "–≤—ñ–¥–ø—É—Å—Ç–∏—Ç–∏" max-height, —â–æ–± –Ω–µ —Ä—ñ–∑–∞–ª–æ –ø—Ä–∏ responsive
      inner.addEventListener('transitionend', (e) => {
        if (e.propertyName !== 'max-height') return;
        if (isOpen) {
          inner.style.setProperty('max-height', 'none', 'important');
        }
      });

      btn.addEventListener('click', () => {
        isOpen = !isOpen;
        setBtn();

        if (isOpen) open();
        else {
          // —è–∫—â–æ –±—É–ª–æ none ‚Äî —Ç—Ä–µ–±–∞ –∑–∞—Ñ—ñ–∫—Å—É–≤–∞—Ç–∏ –ø–µ—Ä–µ–¥ –∞–Ω—ñ–º–∞—Ü—ñ—î—é
          if (inner.style.maxHeight === 'none') {
            inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');
            inner.getBoundingClientRect();
          }
          close();
        }
      });

      // init (closed)
      p.textContent = shortText;
      setBtn();
      // –≤–∏—Å—Ç–∞–≤–ª—è—î–º–æ —Å—Ç–∞—Ä—Ç–æ–≤—É –≤–∏—Å–æ—Ç—É –ø—ñ–¥ –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç
      inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');

      // optional: –Ω–∞ —Ä–µ—Å–∞–π–∑—ñ –∫–æ—Ä–∏–≥—É–≤–∞—Ç–∏, —è–∫—â–æ –∑–∞–∫—Ä–∏—Ç–æ
      const ro = new ResizeObserver(() => {
        if (isOpen) return;
        inner.style.setProperty('max-height', inner.scrollHeight + 'px', 'important');
      });
      ro.observe(block);
    });

    const annotationRoot =
      document.querySelector('.testartem .reviews__annotation[data-words]') ||
      document.querySelector('.reviews__annotation[data-words]');
    if (!annotationRoot) return;

    /*Reviews annotation read more*/
    const annotationLimit = parseInt(annotationRoot.dataset.words, 10);
    if (!annotationLimit) return;

    // –ü–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç (—É—Å—ñ <p>)
    const annotationFullHTML = annotationRoot.innerHTML;
    const annotationFullText = annotationRoot.textContent.trim().replace(/\s+/g, ' ');

    const annotationWords = annotationFullText.split(' ');
    if (annotationWords.length <= annotationLimit) return;

    const annotationShortText = annotationWords.slice(0, annotationLimit).join(' ') + '‚Ä¶';

    // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä, —è–∫–∏–π –∞–Ω—ñ–º—É—î–º–æ
    const annotationInner = document.createElement('div');
    annotationInner.className = 'reviews__annotation-inner';
    annotationInner.innerHTML = `<p>${annotationShortText}</p>`;

    // –ö–Ω–æ–ø–∫–∞
    const annotationToggle = document.createElement('button');
    annotationToggle.type = 'button';
    annotationToggle.className = 'reviews__annotation-toggle';

    let annotationIsOpen = false;

    const annotationSetButton = () => {
      annotationToggle.textContent = annotationIsOpen ? 'Show less' : 'Learn more';
    };

    const annotationSetMaxHeight = () => {
      annotationInner.style.setProperty(
        'max-height',
        annotationInner.scrollHeight + 'px',
        'important',
      );
    };

    const annotationOpen = () => {
      annotationInner.innerHTML = annotationFullHTML;

      annotationInner.style.setProperty('max-height', '0px', 'important');
      annotationInner.getBoundingClientRect(); // reflow
      annotationSetMaxHeight();
    };

    const annotationClose = () => {
      if (annotationInner.style.maxHeight === 'none') {
        annotationInner.style.setProperty(
          'max-height',
          annotationInner.scrollHeight + 'px',
          'important',
        );
        annotationInner.getBoundingClientRect();
      }

      annotationInner.innerHTML = `<p>${annotationShortText}</p>`;
      annotationSetMaxHeight();
    };

    annotationInner.addEventListener('transitionend', (e) => {
      if (e.propertyName !== 'max-height') return;
      if (annotationIsOpen) {
        annotationInner.style.setProperty('max-height', 'none', 'important');
      }
    });

    annotationToggle.addEventListener('click', () => {
      annotationIsOpen = !annotationIsOpen;
      annotationSetButton();
      annotationIsOpen ? annotationOpen() : annotationClose();
    });

    // –ú–æ–Ω—Ç–∞–∂
    annotationRoot.innerHTML = '';
    annotationRoot.appendChild(annotationInner);
    annotationRoot.appendChild(annotationToggle);

    // Init
    annotationSetButton();
    annotationSetMaxHeight();

    // Resize safety
    const annotationRO = new ResizeObserver(() => {
      if (!annotationIsOpen) {
        annotationSetMaxHeight();
      }
    });
    annotationRO.observe(annotationRoot);

    /*Health optimization scroll*/
    const hoViewport =
      document.querySelector('.testartem .health-optimization__list') ||
      document.querySelector('.health-optimization__list');
    if (!hoViewport) return;

    const hoTrack = hoViewport.querySelector('.health-optimization__track');
    if (!hoTrack) return;

    const hoMOBILE_BP = 1023;

    // position
    let hoX = 0;
    let hoDir = 1; // 1 ‚Üí forward, -1 ‚Üí back (mobile)
    let hoRafId = null; // mobile RAF
    let hoMode = null; // 'mobile' | 'desktop'

    // smooth wheel (desktop)
    let hoTargetX = 0;
    let hoEaseRafId = null;
    const hoEASE = 0.12; // 0.08..0.18 (bigger = faster)
    const ho_WHEEL_SENS = 0.9; // wheel sensitivity

    const hoIsMobile = () => window.innerWidth <= hoMOBILE_BP;

    const hoMaxScroll = () => {
      const vw = hoViewport.clientWidth;
      const tw = hoTrack.scrollWidth;
      return Math.max(0, tw - vw);
    };

    const hoClamp = (val, min, max) => Math.max(min, Math.min(val, max));

    const hoSetX = (val) => {
      hoX = val;
      hoTrack.style.setProperty('transform', `translate3d(${-hoX}px, 0, 0)`, 'important');
    };

    /* ===== MOBILE: pendulum auto scroll ===== */
    const hoStartAuto = () => {
      hoStopAuto();

      const hoSpeed = 0.35; // üëà speed

      const hoTick = () => {
        const max = hoMaxScroll();
        if (max <= 0) {
          hoRafId = requestAnimationFrame(hoTick);
          return;
        }

        hoX += hoSpeed * hoDir;

        if (hoX >= max) {
          hoX = max;
          hoDir = -1;
        } else if (hoX <= 0) {
          hoX = 0;
          hoDir = 1;
        }

        hoSetX(hoX);
        hoRafId = requestAnimationFrame(hoTick);
      };

      hoRafId = requestAnimationFrame(hoTick);
    };

    const hoStopAuto = () => {
      if (hoRafId) cancelAnimationFrame(hoRafId);
      hoRafId = null;
    };

    /* ===== DESKTOP: wheel scroll (smooth inertia) ===== */
    let hoPointerX = null;
    let hoPointerY = null;

    window.addEventListener(
      'mousemove',
      (ev) => {
        hoPointerX = ev.clientX;
        hoPointerY = ev.clientY;
      },
      { passive: true },
    );

    const hoIsPointerOverViewport = () => {
      if (hoPointerX === null || hoPointerY === null) return false;
      const el = document.elementFromPoint(hoPointerX, hoPointerY);
      return !!el && hoViewport.contains(el);
    };

    const hoStopEase = () => {
      if (hoEaseRafId) cancelAnimationFrame(hoEaseRafId);
      hoEaseRafId = null;
    };

    const hoStartEase = () => {
      if (hoEaseRafId) return;

      const step = () => {
        const max = hoMaxScroll();

        hoTargetX = hoClamp(hoTargetX, 0, max);

        const diff = hoTargetX - hoX;

        if (Math.abs(diff) < 0.25) {
          hoSetX(hoTargetX);
          hoEaseRafId = null;
          return;
        }

        hoSetX(hoX + diff * hoEASE);
        hoEaseRafId = requestAnimationFrame(step);
      };

      hoEaseRafId = requestAnimationFrame(step);
    };

    const hoOnWheel = (e) => {
      if (hoMode !== 'desktop') return;

      // ‚úÖ only when pointer is really over the section (no hover bug)
      if (!hoIsPointerOverViewport()) return;

      const max = hoMaxScroll();
      if (max <= 0) return;

      const delta = e.deltaY;

      // if already at edges and trying to go further ‚Üí let page scroll
      const atStart = hoTargetX <= 0 && delta < 0;
      const atEnd = hoTargetX >= max && delta > 0;
      if (atStart || atEnd) return;

      e.preventDefault();

      hoTargetX += delta * ho_WHEEL_SENS;
      hoTargetX = hoClamp(hoTargetX, 0, max);

      hoStartEase();
    };

    /* ===== MODE SWITCH ===== */
    const hoApplyMode = () => {
      const nextMode = hoIsMobile() ? 'mobile' : 'desktop';
      if (nextMode === hoMode) return;

      hoMode = nextMode;

      // stop everything
      hoStopAuto();
      hoStopEase();

      // reset position
      const max = hoMaxScroll();
      hoX = 0;
      hoTargetX = 0;
      hoDir = 1;
      hoSetX(0);

      if (hoMode === 'mobile') {
        window.removeEventListener('wheel', hoOnWheel);
        hoStartAuto();
      } else {
        window.addEventListener('wheel', hoOnWheel, { passive: false });
        // ensure clamped on desktop
        hoSetX(hoClamp(hoX, 0, max));
      }
    };

    hoApplyMode();

    window.addEventListener('resize', () => {
      hoApplyMode();

      // clamp current values after resize
      const max = hoMaxScroll();
      hoX = hoClamp(hoX, 0, max);
      hoTargetX = hoClamp(hoTargetX, 0, max);
      hoSetX(hoX);
    });
  });
</script>
